---
title: "Введение в иерархический кластерный анализ: матрица расстояний, метод агломерации, дендрограмма"
author: "Алла Тамбовцева"
output:
  pdf_document:
    latex_engine: xelatex
mainfont: CMU Serif
header-includes:
- \usepackage[russian]{babel}
- \usepackage{hyperref}
- \hypersetup{colorlinks = true, urlcolor = blue, linkcolor=blue}
---

\large
Реализуем в R иерархический кластерный анализ, который мы проделали на семинаре вручную. У нас есть четыре наблюдения и две переменные, $X$ и $Y$. Запишем значения в векторы, а затем объединим их в датафрейм:

```{r}
x <- c(0, 7, 1, 4)
y <- c(4, 0, 2, 2)

dat <- cbind.data.frame(x, y)
dat
```

**Примечание 1:** `cbind` соответствует объединению по столбцам (от *columns*), `rbind` — объединению по строкам (от *rows*). 

**Примечание 2:** в данном случае функция `cbind()` тоже бы подошла, только стоит иметь в виду, что она создаёт матрицу, а не датафрейм. Проблема может возникнуть тогда, когда `x` и `y` являются векторами разного типа, при объединении в матрицу все элементы будут приведены к одному типу. Победит более сильный тип: например, строковый (*character*) вытеснит числовой (*numeric*), и все элементы станут текстовыми.

Построим матрицу расстояний `D`, но прежде шкалируем наши данные с помощью функции `scale()`: вычтем из каждого значения в столбце `x` среднее по столбцу и поделим на стандартное отклонение по столбцу, затем проделаем то же самое для столбца `y`:

```{r}
dist(scale(dat))
```

Матрица в R получилась довольно экономной: она показывает только расстояния между различными точками и не дублирует одни и те же расстояния, предполагая, что матрица симметричная. По умолчанию функция `dist()` считает евклидово расстояние. Запросим документацию функции через `?`:

```{r, eval=FALSE}
?dist
```

Список доступных расстояний:

* `euclidean`: евклидово расстояние;
* `maximum`: расстояние Чебышёва;
* `manhattan`: манхэттенское расстояние;
* `canberra`: [канберрское](https://en.wikipedia.org/wiki/Canberra_distance) расстояние;
* `binary`: асимметричное бинарное расстояние;
* `minkowski`: расстояние [Минковского](https://en.wikipedia.org/wiki/Minkowski_distance).

Вычислим манхэттенское расстояние (оно было нужно нам по условию) и сохраним матрицу расстояний в переменную `D`:

```{r}
D <- dist(scale(dat), method = "manhattan")
D
```

Теперь запустим иерархический кластерный анализ, выберем метод дальнего соседа, метод полной связи (`complete`):

```{r}
hc <- hclust(D, method = "complete")
hc
```

По умолчанию функция `hclust()` использует именно этот метод, поэтому в данном случае аргумент `method` можно было бы опустить. Список основных методов такой:

* `complete`: метод полной связи;
* `single`: метод одиночной связи;
* `average`: метод средней связи;
* `median`: метод медианной связи;
* `centroid`: метод центроидной связи.

Осталось только построить дендрограмму, для этого потребуется базовая функция `plot()`:

```{r, fig.height=3.5}
plot(hc, main = "Complete linkage method")
```

Если мы определились с числом кластеров, можем выделить их на дендрограмме явно, с помощью прямоугольников:

```{r, fig.height=3.5}
plot(hc, main = "Complete linkage method")
rect.hclust(hc, k = 2, border = "red")
```

**Примечание:**  функция `rect.hclust()` добавляет прямоугольники на уже существующий график, то есть накладывает ещё один слой c графическими элементами. Поэтому эта строка с кодом должна запускаться сразу после `plot()`. Если запустить её два раза с разным `k`, не перезапустив строку с `plot()`, прямоугольники тоже добавятся два раза, поэтому не забывайте обновлять саму дендрограмму.

Из объекта `hc`, который нам создала функция `hclust()`, можно извлекать отдельные элементы. Например, расстояния, при которых производилось объединение кластеров на каждой итерации алгоритма:

```{r}
hc$height
```

Или метки наблюдений в том порядке, в котором они упорядочены на дендрограмме:

```{r}
hc$order
```

А ещё меткам можно присвоить свои обозначения, если текущие нас не устраивают. Создадим вектор, состоящий из букв A, B, C, D:

```{r}
labs <- LETTERS[1:4]
labs
```

**Примечание:** `LETTERS` — встроенный вектор из заглавных букв английского алфавита, выбираем первые четыре. Есть ещё вектор `letters` (строчные буквы английского алфавита), `month.name` (названия месяцев на английском) и  `month.abb` (сокращённые названия месяцев на английском). 

Запишем новые метки в `hc`:

```{r}
hc$labels <- labs
```

И построим дендрограмму по `hc` ещё раз:

```{r, fig.height=3.5}
plot(hc, main = "Complete linkage method")
```


